import os
import cv2
import math
import torch
import random
import numpy as np
import concurrent.futures
import matplotlib.pyplot as plt
import torch.nn.functional as F

from tqdm import tqdm
from utils.logger import *
from scipy.stats import norm

def augment(rgb, nir, video_data, idx, length, num_augments):

    T = length

    probability = 0.5

    video_list = []
    speed_list = []
    augment_video_list = []


    for i in range(num_augments):

        video = rgb.detach().numpy()

        video, speed = augment_speed(video, idx, length)
        video = augment_horizontal_flip(video)
        video = augment_time_reversal(video)
        video = augment_gaussian_noise(video)
        video = random_resized_crop(video)

        video = np.clip(video, 0, 255).astype(np.uint8)
        video = torch.from_numpy(video)

        video = video.permute(1, 0, 2, 3)  # [T, C, H, W]

        processed_video = torch.zeros_like(video)

        if random.random() > probability:
            processed_video = video
        else:
            for t in range(T):

                frame = video[t].clone()
                processed_frame = augment_video(frame)

                processed_frame = cv2.cvtColor(processed_frame, cv2.COLOR_BGR2RGB)
                processed_video[t] = torch.from_numpy(processed_frame).permute(2, 0, 1)

        video_list.append(video)
        speed_list.append(speed)
        augment_video_list.append(processed_video.clone())

    video_data['rgb'] = video_list if num_augments > 1 else video_list[0]
    video_data['speed'] = speed_list if num_augments > 1 else speed_list[0]
    video_data['augment_rgb'] = augment_video_list if num_augments > 1 else augment_video_list[0]

    return video_data

def augment_video(frame):

    frame = frame.permute(1, 2, 0).contiguous().numpy()
    frame = cv2.cvtColor(frame, cv2.COLOR_RGB2BGR)

    light_params = {
        'light_position': (64, 64),
        'direction': 45,
        'max_brightness': 255,
        'min_brightness': 0,
        'linear_decay_rate': None,
        'transparency': None,
        'mode': 'gaussian',
        'possibility': 0.5,  # the possibility of adding parallel light
        'add_brightness': False,  # scale up the brightness of the whole image
        'add_light': True,  # add parallel light
        'brightness_factor': 0.7,
        'is_fix': False  # if True, the light position will be fixed, else the position will be random
    }

    if not light_params['is_fix']:
        random_x = random.randint(0, 127)
        random_y = random.randint(0, 127)
        light_params['light_position'] = (random_x, random_y)
        light_params['direction'] = random.randint(0, 90)
        light_params['transparency'] = random.uniform(0.1, 0.9)

    if light_params['add_brightness']:
        processed_frame = adjust_brightness(frame, light_params['brightness_factor'])
    elif light_params['add_light']:
        processed_frame = add_parallel_light(
            frame,
            light_position=light_params['light_position'],
            direction=light_params['direction'],
            max_brightness=light_params['max_brightness'],
            min_brightness=light_params['min_brightness'],
            mode=light_params['mode'],
            linear_decay_rate=light_params['linear_decay_rate'],
            transparency=light_params['transparency']
        )
    else:
        raise "No augmentation method specified. Please set 'add_brightness' or 'add_light' to True."

    return processed_frame

def _decayed_value_in_norm(x, max_value, min_value, center, range):
    """
    Decay from max value to min value following Gaussian/Normal distribution
    """
    radius = range / 3
    center_prob = norm.pdf(center, center, radius)
    x_prob = norm.pdf(x, center, radius)
    x_value = (x_prob / center_prob) * (max_value - min_value) + min_value
    return x_value


def _decayed_value_in_linear(x, max_value, padding_center, decay_rate):
    """
    Decay from max value to min value with static linear decay rate.
    """
    x_value = max_value - abs(padding_center - x) * decay_rate
    if x_value < 0:
        x_value = 1
    return x_value


def generate_parallel_light_mask(mask_size,
                                 position=None,
                                 direction=None,
                                 max_brightness=255,
                                 min_brightness=0,
                                 mode="gaussian",
                                 linear_decay_rate=None):
    """
    Generate decayed light mask generated by light strip given its position, direction
    Args:
        mask_size: tuple of integers (w, h) defining generated mask size
        position: tuple of integers (x, y) defining the center of light strip position,
                  which is the reference point during rotating
        direction: integer from 0 to 360 to indicate the rotation degree of light strip
        max_brightness: integer that max brightness in the mask
        min_brightness: integer that min brightness in the mask
        mode: the way that brightness decay from max to min: linear or gaussian
        linear_decay_rate: only valid in linear_static mode. Suggested value is within [0.2, 2]
    Return:
        light_mask: ndarray in float type consisting value from 0 to strength
    """
    if position is None:
        pos_x = random.randint(0, mask_size[0])
        pos_y = random.randint(0, mask_size[1])
    else:
        pos_x = position[0]
        pos_y = position[1]
    if direction is None:
        direction = random.randint(0, 360)
        print("Rotate degree: ", direction)
    if linear_decay_rate is None:
        if mode == "linear_static":
            linear_decay_rate = random.uniform(0.2, 2)
        if mode == "linear_dynamic":
            linear_decay_rate = (max_brightness - min_brightness) / max(mask_size)
    assert mode in ["linear_dynamic", "linear_static", "gaussian"], \
        "mode must be linear_dynamic, linear_static or gaussian"
    padding = int(max(mask_size) * np.sqrt(2))
    # add padding to satisfy cropping after rotating
    canvas_x = padding * 2 + mask_size[0]
    canvas_y = padding * 2 + mask_size[1]
    mask = np.zeros(shape=(canvas_y, canvas_x), dtype=np.float32)
    # initial mask's up left corner and bottom right corner coordinate
    init_mask_ul = (int(padding), int(padding))
    init_mask_br = (int(padding + mask_size[0]), int(padding + mask_size[1]))
    init_light_pos = (padding + pos_x, padding + pos_y)
    # fill in mask row by row with value decayed from center
    for i in range(canvas_y):
        if mode == "linear_static" or mode == "linear_dynamic":
            i_value = _decayed_value_in_linear(i, max_brightness, init_light_pos[1], linear_decay_rate)
        elif mode == "gaussian":
            i_value = _decayed_value_in_norm(i, max_brightness, min_brightness, init_light_pos[1], mask_size[1])
        else:
            i_value = 0
        mask[i] = i_value
    # rotate mask
    rotate_M = cv2.getRotationMatrix2D(init_light_pos, direction, 1)
    mask = cv2.warpAffine(mask, rotate_M, (canvas_x, canvas_y))
    # crop
    mask = mask[init_mask_ul[1]:init_mask_br[1], init_mask_ul[0]:init_mask_br[0]]
    mask = np.asarray(mask, dtype=np.uint8)
    # add median blur
    mask = cv2.medianBlur(mask, 9)
    mask = 255 - mask

    return mask


def add_parallel_light(frame, light_position=None, direction=None, max_brightness=255, min_brightness=0,
                       mode="gaussian", linear_decay_rate=None, transparency=None):
    """
    Add mask generated from parallel light to given image
    Args:
        frame: Input image in BGR format (numpy array)
        light_position: Position of light source (x, y)
        direction: Light direction in degrees (0-360)
        max_brightness, min_brightness: Brightness range
        mode: "gaussian", "linear_static", or "linear_dynamic"
        linear_decay_rate: Rate of decay for linear modes
        transparency: Blending factor (0-1)
    Returns:
        Processed image with parallel light effect
    """
    if transparency is None:
        transparency = random.uniform(0.5, 0.85)

    height, width, _ = frame.shape
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)
    mask = generate_parallel_light_mask(mask_size=(width, height),
                                        position=light_position,
                                        direction=direction,
                                        max_brightness=max_brightness,
                                        min_brightness=min_brightness,
                                        mode=mode,
                                        linear_decay_rate=linear_decay_rate)
    hsv[:, :, 2] = hsv[:, :, 2] * transparency + mask * (1 - transparency)
    frame = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)
    frame[frame > 255] = 255
    frame = np.asarray(frame, dtype=np.uint8)
    return frame


def adjust_brightness(frame, brightness_factor):
    """
    Adjust the brightness of an image.
    Args:
        frame: Input image in BGR format (numpy array)
        brightness_factor: Float value to adjust brightness
                          > 1.0 increases brightness
                          = 1.0 keeps original brightness
                          < 1.0 decreases brightness
    Returns:
        Processed image with adjusted brightness
    """
    # Convert BGR to HSV
    hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV)

    # Scale the V channel by brightness_factor
    hsv[:, :, 2] = np.clip(hsv[:, :, 2] * brightness_factor, 0, 255).astype(np.uint8)

    # Convert back to BGR
    result = cv2.cvtColor(hsv, cv2.COLOR_HSV2BGR)

    return result


def resample_clip(video, length):
    video = np.transpose(video, (3,0,1,2)).astype(float)
    video = interpolate_clip(video, length)
    video = np.transpose(video, (1,2,3,0))
    return video


def arrange_channels(imgs, channels):
    d = {'b':0, 'g':1, 'r':2, 'n':3}
    channel_order = [d[c] for c in channels]
    imgs = imgs[:,:,:,channel_order]
    return imgs


def prepare_clip(clip, channels):
    clip = arrange_channels(clip, channels)
    clip = np.transpose(clip, (3, 0, 1, 2)) # [C,T,H,W]
    clip = clip.astype(np.float64)
    return clip

def augment_speed(video, idx, length, channels='rgb', speed_slow=0.6, speed_fast=1.4):
    ''' Interpolates clip to frames_per_clip length given slicing indices, which
        can be floats.
    '''
    vid_len = len(video)
    min_idx = idx[0]
    speed_fast = min(speed_fast, math.floor((vid_len - min_idx) / length * 10) / 10)

    speed = np.random.uniform(speed_slow, speed_fast)
    max_idx = np.round(length * speed + min_idx).astype(int)
    if max_idx > vid_len:
        print(f"max_idx: {max_idx}, vid_len: {vid_len}, speed: {speed}")
        raise Exception("max_idx > vid_len")

    clip = video[min_idx:max_idx]
    clip = prepare_clip(clip, channels)
    interpolated_clip = interpolate_clip(clip, length)
    return interpolated_clip, speed


def interpolate_clip(clip, length):
    '''
    Input:
        clip: numpy array of shape [C,T,H,W]
        length: number of time points in output interpolated sequence
    Returns:
        Tensor of shape [C,T,H,W]
    '''
    clip = torch.from_numpy(clip[np.newaxis])
    clip = F.interpolate(clip, (length, 128, 128), mode='trilinear', align_corners=True)
    return clip[0].numpy()


def resize_clip(clip, length):
    '''
    Input:
        clip: numpy array of shape [C,T,H,W]
        length: number of time points in output interpolated sequence
    Returns:
        Tensor of shape [C,T,H,W]
    '''
    T = clip.shape[1]
    clip = torch.from_numpy(np.ascontiguousarray(clip[np.newaxis]))
    clip = F.interpolate(clip, (T, length, length), mode='trilinear', align_corners=False)
    return clip[0].numpy()


def random_resized_crop(clip, crop_scale_lims=[0.5, 1]):
    ''' Randomly crop a subregion of the video and resize it back to original size.
    Arguments:
        clip (np.array): expects [C,T,H,W]
    Returns:
        clip (np.array): same dimensions as input
    '''
    C,T,H,W = clip.shape
    crop_scale = np.random.uniform(crop_scale_lims[0], crop_scale_lims[1])
    crop_length = np.round(crop_scale * H).astype(int)
    crop_start_lim = H - (crop_length)
    x1 = np.random.randint(0, crop_start_lim+1)
    y1 = x1
    x2 = x1 + crop_length
    y2 = y1 + crop_length
    cropped_clip = clip[:,:,y1:y2,x1:x2]
    resized_clip = resize_clip(cropped_clip, H)
    return resized_clip


def augment_gaussian_noise(clip):
    clip = clip + np.random.normal(0, 2, clip.shape)
    return clip


def augment_illumination_noise(clip):
    clip = clip + np.random.normal(0, 10)
    return clip


def augment_time_reversal(clip):
    if np.random.rand() > 0.5:
        clip = np.flip(clip, 1)
    return clip


def augment_horizontal_flip(clip):
    if np.random.rand() > 0.5:
        clip = np.flip(clip, 3)
    return clip